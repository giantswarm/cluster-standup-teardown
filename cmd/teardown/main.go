package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path"

	. "github.com/onsi/gomega" // nolint:staticcheck

	"github.com/giantswarm/cluster-standup-teardown/cmd/standup/types"
	"github.com/giantswarm/cluster-standup-teardown/pkg/teardown"

	"github.com/giantswarm/clustertest/v2"
	"github.com/giantswarm/clustertest/v2/pkg/application"
	"github.com/giantswarm/clustertest/v2/pkg/organization"
	"github.com/spf13/cobra"
)

var (
	teardownCmd = &cobra.Command{
		Use:     "teardown",
		Long:    "Teardown completely removes a previously created test cluster.\nCan take in the results.json produced by `standup` to quickly clean up a test cluster.\nA valid Management Cluster kubeconfig must be available and set to the `E2E_KUBECONFIG` environment variable.",
		Example: "teardown --context capa --standup-directory ./",
		Args:    cobra.NoArgs,
		RunE:    run,
	}

	provider         string
	kubeContext      string
	clusterName      string
	orgName          string
	standupDirectory string
	cleanupResults   bool
)

func init() {
	teardownCmd.Flags().StringVar(&provider, "provider", "", "The provider")
	teardownCmd.Flags().StringVar(&kubeContext, "context", "", "The kubernetes context to use (required)")
	teardownCmd.Flags().StringVar(&clusterName, "cluster-name", "", "The name of the cluster to tear down")
	teardownCmd.Flags().StringVar(&orgName, "org-name", "", "The org the cluster belongs to")
	teardownCmd.Flags().StringVar(&standupDirectory, "standup-directory", "", "The directory containing the results from 'standup'")
	teardownCmd.Flags().BoolVar(&cleanupResults, "cleanup-standup-results", true, "Remove the results and kubeconfig generated by 'standup'")

	_ = teardownCmd.MarkFlagRequired("context")
}

func main() {
	if err := teardownCmd.Execute(); err != nil {
		os.Exit(1)
	}
}

func run(cmd *cobra.Command, args []string) error {
	// Required to be able to use our module with Gomega assertions without Ginkgo
	RegisterFailHandler(func(message string, callerSkip ...int) {
		panic(message)
	})

	cmd.SilenceUsage = true

	// Load cluster details from previous standup results
	if standupDirectory != "" {
		resultBytes, err := os.ReadFile(path.Join(standupDirectory, "results.json")) // nolint:gosec
		if err != nil {
			return err
		}

		var standupResults types.StandupResult
		err = json.Unmarshal(resultBytes, &standupResults)
		if err != nil {
			return err
		}

		provider = standupResults.Provider
		clusterName = standupResults.ClusterName
		orgName = standupResults.OrgName
	} else if provider == "" || clusterName == "" || orgName == "" {
		return fmt.Errorf("please provide either a standup-directory or all other flags")
	}

	fmt.Printf("Tearing down cluster...\n\nProvider:\t%s\nCluster Name:\t%s\nOrg Name:\t%s\n\n", provider, clusterName, orgName)

	framework, err := clustertest.New(kubeContext)
	if err != nil {
		return err
	}

	provider := application.Provider(provider)

	cluster := application.NewClusterApp(clusterName, provider).WithOrg(organization.New(orgName))

	err = teardown.New(framework).Teardown(cluster)
	if err != nil {
		return err
	}

	if standupDirectory != "" && cleanupResults {
		err = os.Remove(path.Join(standupDirectory, "kubeconfig"))
		if err != nil {
			return err
		}
		err = os.Remove(path.Join(standupDirectory, "results.json"))
		if err != nil {
			return err
		}
	}

	return nil
}
